---
title: "Notes on Virtualization.Framework"
date: 2020-12-29
draft: true
tags: [
    "macos",
]
summary: "Notes from reversing implmentation details of the macOS Virtualization.Framework"
---

Big Sur on macOS that added the
[Virtualization.Framework](https://developer.apple.com/documentation/virtualization?language=objc).
This is a higher-level API for creating and managing virtual machines than the
[Hypervisor.Framework](https://developer.apple.com/documentation/hypervisor?language=objc)
which gives you a seemingly thin wrapper around [Intel
VT-x](https://en.wikipedia.org/wiki/X86_virtualization#Intel_virtualization_(VT-x)).

The great thing about Virtualization.Framework is that it provides a fairly
high-level API to boot into a Linux Kernel:
[`VZLinuxBootLoader`](https://developer.apple.com/documentation/virtualization/vzlinuxbootloader?language=objc).
This was possible with Hypervisor.Framework, you would just need some
bootstrapping implementation like [`xhyve`](https://github.com/machyve/xhyve).

Recently I was using [`vftool`](https://github.com/evansm7/vftool) which
provides a thin wrapper CLI around Virtualization.Framework but I was seeing
fairly unreliable results with booting various Linux distributions. The
[workflow outlined in the Github issues vftool by user
droidix](https://github.com/evansm7/vftool/issues/2#issuecomment-735455161) was
helpful in getting an Ubuntu VM setup but following similar workflows didn't
quite work for all Linux distributions. I could successfully boot Ubuntu,
Fedora, and OpenSUSE using the same rough workflow described here but was less
successful in booting Arch and TinyCoreLinux. TinyCoreLinux is notable example
distribution because that is the 'test' distribution that xhyve uses. I had
assumed (with no clear justification) that Virtualization.Framework was
borrowing ideas from xhyve given that xhyve is used in popular projects like
[HyperKit](https://github.com/moby/hyperkit). Attempting to boot TinyCoreLinux
using vftool lead to a "successful" boot of a VM but as soon as the the VM
starts it transitions to a 'Done' state within a second or so.

```shell
$ vftool -k tinycorelinux/vmlinuz -i tinycorelinux/core.gz -m 1024 -a 'console=hvc0'
2020-12-29 11:25:19.792 vftool[54377:1257388] vftool (v0.3 10/12/2020) starting
2020-12-29 11:25:19.793 vftool[54377:1257388] +++ kernel at tinycorelinux/vmlinuz, initrd at tinycorelinux/core.gz, cmdline 'console=hvc0', 1 cpus, 1024MB memory
2020-12-29 11:25:19.794 vftool[54377:1257388] +++ fd 3 connected to /dev/ttys008
2020-12-29 11:25:19.794 vftool[54377:1257388] +++ Waiting for connection to:  /dev/ttys008
2020-12-29 11:25:24.905 vftool[54377:1257388] +++ Configuration validated.
2020-12-29 11:25:24.905 vftool[54377:1257388] +++ canStart = 1, vm state 0
2020-12-29 11:25:25.266 vftool[54377:1257486] +++ VM started
2020-12-29 11:25:25.913 vftool[54377:1257388] +++ Done, state = 3
$
```

It is _very_ possible I'm not using vftool properly, or providing the right
format of kernel or initrd to vftool. However, there isn't much of a feedback
loop. It is very unclear _why_ this failed to successfully boot.
While it is probably not the most scientific approach to debugging, I started to
dig more into how Virtualization.Framework was implemented so I could see if I
could better understand what I might be doing wrong (Spoiler: I didn't figure
this out but I took notes that seem interesting).

## Debugging vftool and Virtualization.Framework

My original approach was debugging vftool with lldb and trying to find some
indication of something failing.

## Reversing com.apple.Virtualization.VirtualMachine.xpc 

## Misc Notes

### Debugging VirtualMachine.xpc
Attaching a debugger to the VirtualMachine XPC service is likely useful as it
seems clear that most of the interesting bootstrapping code lives there.
However, I believe I'd need to disable SIP to do this and I don't love
disabling security features on my hardware. If I revisit this (or someone
else does) starting from here seems reasonable.

### Gotcha in using Hopper's dead code removal

Reversing Objective-C code that makes use of blocks took me some time. It was
especially confusing to use Hopper's lifting of ASM to C which, by default,
would remove "dead" code. This would generate C like:

```C
  if (rbx != 0x0) {
          var_40 = *__NSConcreteStackBlock;
          [rbx retain];
          dispatch_async(*__dispatch_main_q, &var_40);
```

Which is perplexing since `var_40` _should_ be a block but is clearly just a
pointer to a 'type'. Looking at the ASM directly was more useful here:

```
000000010001abd1         mov        rax, qword [__NSConcreteStackBlock_1000b4008] ; __NSConcreteStackBlock_1000b4008
000000010001abd8         mov        qword [rbp+var_40], rax
000000010001abdc         mov        eax, 0xc2000000
000000010001abe1         mov        qword [rbp+var_38], rax
000000010001abe5         lea        rax, qword [sub_10001ac60]                  ; sub_10001ac60
000000010001abec         mov        qword [rbp+var_30], rax
000000010001abf0         lea        rax, qword [__ZTINSt3__117bad_function_callE+696] ; 
# <snip>
000000010001ac16         call       imp___stubs__dispatch_async                 ; dispatch_async
```

I eventually sorted out that that the ASM is probably building a [block literal
struct](https://clang.llvm.org/docs/Block-ABI-Apple.html#high-level). Hopper
seems to (understandbly) think the `sub_10001ac60` reference is unused so it
will remove it as dead code. However, I believe this is the `invoke` field of
the block struct which points to the instructions that would be executed by the
`dispatch_async` call.
